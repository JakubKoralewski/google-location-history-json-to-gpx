import './style.scss'
import {buildGPX, StravaBuilder, BaseBuilder} from 'gpx-builder'
const {Point, Metadata} = StravaBuilder.MODELS

interface Location {
    latitudeE7: number,
    longitudeE7: number,
    sourceInfo: {
      deviceTag: number
    }
}

type ISODate = string
type Meters = number
type PlaceId = string
type ZeroTo1Float = number


interface ActivitySegment {
  activitySegment: {
    startLocation: Location
    endLocation: Location,
    duration: {
      startTimestamp: ISODate,
      endTimestamp: ISODate
    },
    distance: Meters,
    activityType: string,
    confidence: ZeroTo1Float,
    activities: { activityType: string, probability: ZeroTo1Float }[],

  } & ConditionalSegment
}

interface CyclingSegment {
  simplifiedRawPath: {
    points: {
      latE7: number,
      lngE7: number,
      accuracyMeters: number,
      timestamp: ISODate
    }[]
  },
  activityType: "CYCLING",
  waypointPath: {
    waypoints: {
      latE7: number,
      lngE7: number,
    }[],
    source: "INFERRED" | string,
    roadSegment: {
      placeId: PlaceId,
      duration: `${number}s`
    }[],
    distanceMeters: Meters,
    travelMode: "BICYCLE",
    confidence: ZeroTo1Float
  }
}

type ConditionalSegment = CyclingSegment

interface Data {
  timelineObjects: (ActivitySegment | {placeVisit: any})[]
}

const inputElement = document.querySelector<HTMLInputElement>('input')!
const segmentsContainer = document.querySelector<HTMLDivElement>('#segments')!
let data: Data | null
let segments: number[] = []
function download(filename: string, data: BlobPart) {
    const url = window.URL.createObjectURL(new Blob([data]))
    const a = document.createElement('a')
    a.style.display = 'none'
    a.href = url
  a.download = filename
    document.body.appendChild(a)
    a.click()
    window.URL.revokeObjectURL(url)
}

function updateSegments() {
  segmentsContainer.innerHTML = ``
  for (const segmentIndex of segments) {
    const as = data!.timelineObjects[segmentIndex] as ActivitySegment
    const dur = as.activitySegment.duration
    const start = new Date(dur.startTimestamp)
    const end = new Date(dur.endTimestamp)
    let child = document.createElement('div')
    child.classList.add('segment')
    let text = `<div>Start:<div> ${ start.toLocaleString() }</div></div>`
    text += `<div>End:<div> ${ end.toLocaleString() }</div></div>`
    text += `<div>Distance:<div>${as.activitySegment.distance/10e2}km</div></div>`
    text += `<div>Type:<div>${as.activitySegment.activityType}</div></div>`
    child.innerHTML = text
    child.addEventListener("click", (e) => {
      const gpxBuilder = new StravaBuilder()
      {
        let points = []
        {
          const startLoc = as.activitySegment.startLocation
          points.push(new Point(startLoc.latitudeE7 / 10e6, startLoc.longitudeE7 / 10e6, {time: start}))
        }
        for (const p of as.activitySegment.simplifiedRawPath.points) {
            points.push(new Point(p.latE7 / 10e6, p.lngE7 / 10e6, {time: new Date(p.timestamp)}))
        }
        {
          const endLoc = as.activitySegment.endLocation
          points.push(new Point(endLoc.latitudeE7 / 10e6, endLoc.longitudeE7 / 10e6, {time: end}))
        }
        console.log({points})
        gpxBuilder.setSegmentPoints(points)
      }
      {
        let waypoints = []
        for (const p of as.activitySegment.waypointPath.waypoints) {
            waypoints.push(new Point(p.latE7 / 10e6, p.lngE7 / 10e6))
        }
        gpxBuilder.setWayPoints(waypoints)
      }
      gpxBuilder.setMetadata(new Metadata({
        desc: `Generated by Jakub Koralewski. ${as.activitySegment.activityType}`
      }))
      const gpxContent = buildGPX(gpxBuilder.toObject())
      download(`${start.toISOString()}.gpx`, gpxContent)
    })
    segmentsContainer.appendChild(child)
  }
}

inputElement.addEventListener("change", (e) => {
  segments =[]
  let file = inputElement.files?.[0]
  if (!file) return;
  console.log(file, e)
  if (!file?.type.includes("json")) {
    alert(`Invalid format ${file.type}`)
    return;
  }
  const reader = new FileReader();
  reader.addEventListener("load", e => {
    let as_string = e.target?.result
    if(typeof as_string !== 'string') throw Error()
    let as_json: Data = JSON.parse(as_string)
    if(as_json === undefined) alert("Invalid data")
    data = as_json
    for (let i = 0; i < as_json.timelineObjects.length; i++) {
      const o = as_json.timelineObjects[i]
      if(!('activitySegment' in o && 'simplifiedRawPath' in o.activitySegment)) continue
      segments.push(i)
    }
    segments.reverse()
    updateSegments()

  })
  reader.readAsText(file)

})
